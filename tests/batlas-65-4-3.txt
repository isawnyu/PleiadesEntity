
    # test programmatic manipulation of geoEntities and geoNames using data associated with entity ID = batlas-65-4-3
    # this set of tests procedes attribute-wise and does not test the load-from-file capabilities; there are other tests for that
        
    # set up a test folder in which to create the entity and its children
    >>> folder = self.folder
        
    # create a geographic entity and verify that we can set and retrieve its Plone id
    >>> enID = 'batlas-65-4-3'
    >>> folder.invokeFactory('GeographicEntityLite', id=enID)
    'batlas-65-4-3'
        
    # get a pointer to the entity, then verify we can set and retrieve its interim title
    >>> en = getattr(folder, enID)
    >>> en.setTitle(enID)
    >>> en.Title()
    'batlas-65-4-3'
        
    # verify that we can set and retrieve the value of the identifier attribute
    >>> en.setIdentifier(enID)
    >>> en.getIdentifier()
    'batlas-65-4-3'
    
    # verify that we can set and retrieve the value of the modernLocation attribute
    >>> sourcetext = u'near Antiochia ad Maeandrum'
    >>> sourcetext_utf8 = sourcetext.encode('utf8')
    >>> en.setModernLocation(sourcetext_utf8)
    >>> resulttext_utf8 = en.getModernLocation()
    >>> resulttext_utf8 == sourcetext_utf8
    True
    >>> resulttext = unicode(resulttext_utf8, 'utf8')
    >>> resulttext == sourcetext
    True
    >>> resulttext == u'near Antiochia ad Maeandrum'
    True
    
    # verify that we can set and retrieve a list of timePeriods 
    >>> sourcelist = ['Roman?']
    >>> en.setTimePeriods(sourcelist)
    >>> results = en.getTimePeriods()
    
    >>> results[0] == 'Roman?'
    True
    
    # verify that we can set and retrieve the appropriate classification type(s)
    >>> en.setGeoEntityType('bridge')
    >>> en.getGeoEntityType()
    'bridge'
    
    # verify that we can set and retrieve a list of secondaryReferences
        
    >>> sourcelist = [u'BAtlas 65 A2', u'Magie 1950, 989']
            
    >>> en.setSecondaryReferences(sourcelist)
    >>> resultlist = en.getSecondaryReferences()
                
    >>> resultlist[0] == sourcelist[0].encode('utf8')
    True
    
    >>> resultlist[1] == sourcelist[1].encode('utf8')
    True
    
    # verify that we can set and retrieve the spatialLocation and spatialGeometryType
        
    >>> en.setSpatialCoordinates('37.90056 28.5605599999999 0.0')
    >>> en.getSpatialCoordinates()
    '37.90056 28.5605599999999 0.0'        
    >>> en.setSpatialGeometryType('point')
    >>> en.getSpatialGeometryType()
    'point'        
    
    # verify that we can set and retrieve a list of contributors
    >>> sourcelist = [u'C. Foss (compiler, west)', u'S. Mitchell (compiler)']
            
    >>> en.setCreators(sourcelist)
    >>> results = en.Creators()
                
    >>> results[0] == u'C. Foss (compiler, west)'
    True
    
    >>> results[1] == u'S. Mitchell (compiler)'
    True
    
    # verify that we can set and retrieve a list of contributors
    >>> sourcelist = [u'R. Talbert (editor)', u'T. Elliott (data normalization and xml encoding)']
            
    >>> en.setContributors(sourcelist)
    >>> results = en.Contributors()
                
    >>> results[0] == u'R. Talbert (editor)'
    True
    
    >>> results[1] == u'T. Elliott (data normalization and xml encoding)'
    True
    
    # verify that we can set and retrieve an appropriate value for the rights attribute
    >>> sourcetext = u'Copyright \U000000A9 2006 Ancient World Mapping Center. All rights reserved. This data is derived from original compilations prepared for the American Philological Association\U00000027s Classical Atlas Project (1988-2000). It is used here with permission of the APA. This data is intended solely for testing purposes in the context of the Ancient World Mapping Center\U00000027s Pleiades Project and may not be reused or redistributed. In its current state, this data may contain errors and omissions and is not appropriate for citation or scholarly use. Any errors or omissions are the result of prototype conversion software, still under development by the AWMC\U00000027s Pleiades Project, and do not reflect the quality and completeness of the original data nor the opinions of its scholarly compilers and editors.'
    >>> sourcetext_utf8 = sourcetext.encode('utf8')
        
    >>> en.setRights(sourcetext_utf8)
    >>> resulttext_utf8 = en.Rights()
            
    >>> resulttext_utf8 == sourcetext_utf8
    True
    >>> resulttext = unicode(resulttext_utf8, 'utf8')
    >>> resulttext == sourcetext
    True
    >>> resulttext == u'Copyright \U000000A9 2006 Ancient World Mapping Center. All rights reserved. This data is derived from original compilations prepared for the American Philological Association\U00000027s Classical Atlas Project (1988-2000). It is used here with permission of the APA. This data is intended solely for testing purposes in the context of the Ancient World Mapping Center\U00000027s Pleiades Project and may not be reused or redistributed. In its current state, this data may contain errors and omissions and is not appropriate for citation or scholarly use. Any errors or omissions are the result of prototype conversion software, still under development by the AWMC\U00000027s Pleiades Project, and do not reflect the quality and completeness of the original data nor the opinions of its scholarly compilers and editors.'
    True
    
    # check to see that programmatic renaming of the entity on the basis of its subordinate names works as expected
    
    >>> finalTitle = setGeoTitleFromNames(en)
     
    >>> soughtFinalTitle = u'Unnamed bridge, modern location: near Antiochia ad Maeandrum'
    >>> soughtFinalTitle_utf8 = soughtFinalTitle.encode('utf8')
    >>> finalTitle == soughtFinalTitle_utf8
    True
    >>> finalTitle = en.Title()
    >>> finalTitle == soughtFinalTitle_utf8
    True

    # check to see that we can set and retrieve a description
    >>> soughtDescription = u'An ancient bridge, attested during the Roman? period (modern location: near Antiochia ad Maeandrum). Its ancient name is not known.'
    >>> en.setDescription(soughtDescription)
    >>> gotDescription = en.Description()
    >>> soughtDescription_utf8 = soughtDescription.encode('utf8')
    >>> soughtDescription_utf8 == gotDescription
    True
    
    